using Geek.Server;
using Geek.Server.Core.Actors.Impl;
{{~ for use in usingspaces ~}}
using {{use}};
{{~ end ~}}

namespace {{space}}
{
    public class {{name}} : {{super}}
	{
		{{~ for mth in methods ~}}
		
		{{mth.declare}}
		{
			{{~ if mth.discard ~}}{{~#************************************************~}}

			{{~ if mth.threadsafe ~}}
			_ = base.{{mth.name}}{{mth.typeparams}}({{mth.paramstr}});
			{{~ else ~}}
			long callChainId = Geek.Server.Core.Actors.Impl.WorkerActor.NextChainId();
			_ = base.Actor.WorkerActor.Enqueue(()=>{return base.{{mth.name}}{{mth.typeparams}}({{mth.paramstr}});}, callChainId, {{mth.timeout}});
			{{~ end ~}}
			return {{mth.returntype}}.CompletedTask;

			{{~ else ~}}{{~#************************************************~}}
			(bool needEnqueue, long chainId)= base.Actor.WorkerActor.IsNeedEnqueue();
			if (!needEnqueue)
			{
				return base.{{mth.name}}{{mth.typeparams}}({{mth.paramstr}});
			}
			return base.Actor.WorkerActor.Enqueue(()=>{return base.{{mth.name}}{{mth.typeparams}}({{mth.paramstr}});}, chainId, {{mth.timeout}});
			{{~ end ~}}{{~#************************************************~}}
		}

		{{~ end ~}}

		public override async Task<ActorRemoteCallResult> RemoteCall(ActorRemoteCallParams paras)
		{
			var result = new ActorRemoteCallResult();
			switch (paras.funcName)
			{
				{{~ for mth in publictaskmethods ~}}
				case "{{mth.name}}":
				{{~ if mth.havetaskreturnvalue ~}}   
				var {{mth.name}}Ret = await {{mth.name}}({{mth.remotecallparamsexpand}});
				result.resultData = MessagePack.MessagePackSerializer.Serialize({{mth.name}}Ret);
				{{~ else ~}}  
				await {{mth.name}}({{mth.remotecallparamsexpand}});
				{{~ end ~}} 
				result.success = true;
				break;
				{{~ end ~}}
				default:
				break;
			}
			return result;
		}
	}
}